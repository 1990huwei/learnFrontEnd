# 第4天：HTML5多媒体与API学习指南

## 学习目标
通过今天的学习，你将掌握HTML5多媒体技术和常用Web API的使用方法，能够创建丰富的交互式网页应用。

## 学习内容
- HTML5音频和视频
- Canvas画布绘图
- 常用Web API（地理位置、本地存储、文件API、Web Workers）
- 实时数据处理和交互功能

## 时长安排
- **总计**: 4小时
- **理论学习**: 1.5小时
- **实践练习**: 2小时
- **总结复习**: 0.5小时

## 前置知识
- 熟悉HTML基础语法
- 理解DOM结构
- 基本的JavaScript语法（变量、函数、事件）

---

## 📹 HTML5音频和视频

### 音频标签 `<audio>`

HTML5提供了原生的音频播放支持，无需插件。

#### 基本语法
```html
<audio controls>
  <source src="music.mp3" type="audio/mpeg">
  <source src="music.ogg" type="audio/ogg">
  您的浏览器不支持音频播放。
</audio>
```

#### 常用属性
- `controls`: 显示播放控件
- `autoplay`: 自动播放（注意浏览器政策限制）
- `loop`: 循环播放
- `muted`: 静音
- `preload`: 预加载策略（none/metadata/auto）

#### 实践示例
```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>音频播放器</title>
</head>
<body>
    <h2>🎵 音频播放器</h2>
    
    <!-- 基础音频播放器 -->
    <audio id="audioPlayer" controls style="width: 100%;">
        <source src="https://www.w3schools.com/html/horse.mp3" type="audio/mpeg">
        您的浏览器不支持音频播放。
    </audio>
    
    <!-- 自定义控制按钮 -->
    <div style="margin-top: 10px;">
        <button onclick="playAudio()">播放</button>
        <button onclick="pauseAudio()">暂停</button>
        <button onclick="changeVolume(0.1)">音量-</button>
        <button onclick="changeVolume(-0.1)">音量+</button>
    </div>
    
    <script>
        const audio = document.getElementById('audioPlayer');
        
        function playAudio() {
            audio.play();
        }
        
        function pauseAudio() {
            audio.pause();
        }
        
        function changeVolume(delta) {
            const newVolume = Math.max(0, Math.min(1, audio.volume + delta));
            audio.volume = newVolume;
        }
        
        // 监听音频事件
        audio.addEventListener('loadstart', () => console.log('开始加载'));
        audio.addEventListener('canplay', () => console.log('可以播放'));
        audio.addEventListener('ended', () => console.log('播放结束'));
    </script>
</body>
</html>
```

### 视频标签 `<video>`

#### 基本语法
```html
<video controls width="640" height="360">
  <source src="movie.mp4" type="video/mp4">
  <source src="movie.webm" type="video/webm">
  <track src="subtitles.vtt" kind="subtitles" srclang="zh-CN" label="中文字幕">
  您的浏览器不支持视频播放。
</video>
```

#### 响应式视频
```html
<style>
  .video-container {
    position: relative;
    width: 100%;
    height: 0;
    padding-bottom: 56.25%; /* 16:9比例 */
  }
  
  .video-container video {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
  }
</style>

<div class="video-container">
  <video controls>
    <source src="video.mp4" type="video/mp4">
  </video>
</div>
```

#### 视频播放器示例
```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>视频播放器</title>
    <style>
        .video-player {
            max-width: 800px;
            margin: 20px auto;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .video-info {
            padding: 15px;
            background: #f5f5f5;
        }
        
        .custom-controls {
            padding: 10px;
            background: #333;
            color: white;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .progress-bar {
            flex: 1;
            height: 5px;
            background: #666;
            border-radius: 3px;
            overflow: hidden;
        }
        
        .progress {
            height: 100%;
            background: #4CAF50;
            width: 0%;
            transition: width 0.1s;
        }
    </style>
</head>
<body>
    <div class="video-player">
        <video id="myVideo" width="100%" onclick="togglePlay()">
            <source src="https://www.w3schools.com/html/mov_bbb.mp4" type="video/mp4">
            您的浏览器不支持视频播放。
        </video>
        
        <div class="custom-controls">
            <button onclick="togglePlay()" id="playBtn">▶️</button>
            <button onclick="skipTime(-10)">⏪</button>
            <button onclick="skipTime(10)">⏩</button>
            <div class="progress-bar" onclick="seek(event)">
                <div class="progress" id="progress"></div>
            </div>
            <span id="timeInfo">0:00 / 0:00</span>
            <button onclick="toggleMute()" id="muteBtn">🔊</button>
        </div>
        
        <div class="video-info">
            <h3>🎬 示例视频</h3>
            <p>这是一个自定义视频播放器的演示，包含播放控制、进度条和时间显示功能。</p>
        </div>
    </div>
    
    <script>
        const video = document.getElementById('myVideo');
        const playBtn = document.getElementById('playBtn');
        const muteBtn = document.getElementById('muteBtn');
        const progress = document.getElementById('progress');
        const timeInfo = document.getElementById('timeInfo');
        
        function togglePlay() {
            if (video.paused) {
                video.play();
                playBtn.textContent = '⏸️';
            } else {
                video.pause();
                playBtn.textContent = '▶️';
            }
        }
        
        function skipTime(seconds) {
            video.currentTime += seconds;
        }
        
        function toggleMute() {
            video.muted = !video.muted;
            muteBtn.textContent = video.muted ? '🔇' : '🔊';
        }
        
        function seek(event) {
            const rect = event.currentTarget.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            const percentage = clickX / rect.width;
            video.currentTime = percentage * video.duration;
        }
        
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }
        
        // 更新进度和时间
        video.addEventListener('timeupdate', () => {
            const percentage = (video.currentTime / video.duration) * 100;
            progress.style.width = percentage + '%';
            timeInfo.textContent = `${formatTime(video.currentTime)} / ${formatTime(video.duration)}`;
        });
        
        video.addEventListener('loadedmetadata', () => {
            timeInfo.textContent = `0:00 / ${formatTime(video.duration)}`;
        });
    </script>
</body>
</html>
```

---

## 🎨 Canvas画布绘图

Canvas提供了强大的2D绘图功能，可以创建图表、游戏、动画等。

### 基础语法
```html
<canvas id="myCanvas" width="400" height="300"></canvas>

<script>
const canvas = document.getElementById('myCanvas');
const ctx = canvas.getContext('2d');

// 绘制矩形
ctx.fillStyle = '#4CAF50';
ctx.fillRect(50, 50, 200, 100);
</script>
```

### Canvas绘图示例
```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Canvas绘图演示</title>
    <style>
        .canvas-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
            margin: 20px;
        }
        
        .canvas-item {
            text-align: center;
        }
        
        canvas {
            border: 2px solid #ddd;
            border-radius: 8px;
        }
        
        .controls {
            margin: 10px 0;
        }
        
        button {
            margin: 5px;
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            background: #2196F3;
            color: white;
            cursor: pointer;
        }
        
        button:hover {
            background: #1976D2;
        }
    </style>
</head>
<body>
    <h1 style="text-align: center;">🎨 Canvas绘图演示</h1>
    
    <div class="canvas-container">
        <!-- 基础图形绘制 -->
        <div class="canvas-item">
            <h3>基础图形</h3>
            <canvas id="shapesCanvas" width="300" height="200"></canvas>
            <div class="controls">
                <button onclick="drawShapes()">绘制图形</button>
                <button onclick="clearCanvas('shapesCanvas')">清除</button>
            </div>
        </div>
        
        <!-- 动态绘图 -->
        <div class="canvas-item">
            <h3>交互绘图</h3>
            <canvas id="drawCanvas" width="300" height="200"></canvas>
            <div class="controls">
                <button onclick="setDrawMode('pen')">画笔</button>
                <button onclick="setDrawMode('eraser')">橡皮</button>
                <button onclick="clearCanvas('drawCanvas')">清除</button>
            </div>
        </div>
        
        <!-- 动画效果 -->
        <div class="canvas-item">
            <h3>动画效果</h3>
            <canvas id="animationCanvas" width="300" height="200"></canvas>
            <div class="controls">
                <button onclick="startAnimation()">开始动画</button>
                <button onclick="stopAnimation()">停止动画</button>
            </div>
        </div>
        
        <!-- 图表绘制 -->
        <div class="canvas-item">
            <h3>数据图表</h3>
            <canvas id="chartCanvas" width="300" height="200"></canvas>
            <div class="controls">
                <button onclick="drawChart()">绘制图表</button>
                <button onclick="updateChart()">更新数据</button>
            </div>
        </div>
    </div>
    
    <script>
        // 基础图形绘制
        function drawShapes() {
            const canvas = document.getElementById('shapesCanvas');
            const ctx = canvas.getContext('2d');
            
            // 清除画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 绘制矩形
            ctx.fillStyle = '#FF6B6B';
            ctx.fillRect(20, 20, 80, 60);
            
            // 绘制圆形
            ctx.fillStyle = '#4ECDC4';
            ctx.beginPath();
            ctx.arc(200, 50, 30, 0, 2 * Math.PI);
            ctx.fill();
            
            // 绘制三角形
            ctx.fillStyle = '#45B7D1';
            ctx.beginPath();
            ctx.moveTo(50, 120);
            ctx.lineTo(100, 120);
            ctx.lineTo(75, 180);
            ctx.closePath();
            ctx.fill();
            
            // 绘制文字
            ctx.fillStyle = '#333';
            ctx.font = '16px Arial';
            ctx.fillText('Canvas绘图', 150, 150);
        }
        
        // 交互绘图功能
        let isDrawing = false;
        let drawMode = 'pen';
        
        function setupDrawCanvas() {
            const canvas = document.getElementById('drawCanvas');
            const ctx = canvas.getContext('2d');
            
            canvas.addEventListener('mousedown', startDraw);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDraw);
            canvas.addEventListener('mouseout', stopDraw);
        }
        
        function startDraw(e) {
            isDrawing = true;
            const rect = e.target.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const ctx = e.target.getContext('2d');
            ctx.beginPath();
            ctx.moveTo(x, y);
        }
        
        function draw(e) {
            if (!isDrawing) return;
            
            const rect = e.target.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const ctx = e.target.getContext('2d');
            
            if (drawMode === 'pen') {
                ctx.globalCompositeOperation = 'source-over';
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
            } else if (drawMode === 'eraser') {
                ctx.globalCompositeOperation = 'destination-out';
                ctx.lineWidth = 10;
            }
            
            ctx.lineTo(x, y);
            ctx.stroke();
        }
        
        function stopDraw() {
            isDrawing = false;
        }
        
        function setDrawMode(mode) {
            drawMode = mode;
        }
        
        // 动画功能
        let animationId;
        let ballX = 50;
        let ballY = 100;
        let ballSpeedX = 2;
        let ballSpeedY = 1.5;
        
        function startAnimation() {
            const canvas = document.getElementById('animationCanvas');
            const ctx = canvas.getContext('2d');
            
            function animate() {
                // 清除画布
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // 更新球的位置
                ballX += ballSpeedX;
                ballY += ballSpeedY;
                
                // 边界反弹
                if (ballX <= 15 || ballX >= canvas.width - 15) {
                    ballSpeedX = -ballSpeedX;
                }
                if (ballY <= 15 || ballY >= canvas.height - 15) {
                    ballSpeedY = -ballSpeedY;
                }
                
                // 绘制球
                ctx.fillStyle = '#FF9500';
                ctx.beginPath();
                ctx.arc(ballX, ballY, 15, 0, 2 * Math.PI);
                ctx.fill();
                
                // 绘制轨迹
                ctx.strokeStyle = 'rgba(255, 149, 0, 0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(ballX, ballY, 20, 0, 2 * Math.PI);
                ctx.stroke();
                
                animationId = requestAnimationFrame(animate);
            }
            
            animate();
        }
        
        function stopAnimation() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
        }
        
        // 图表绘制
        let chartData = [30, 60, 45, 80, 35, 70];
        
        function drawChart() {
            const canvas = document.getElementById('chartCanvas');
            const ctx = canvas.getContext('2d');
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const barWidth = 40;
            const maxHeight = 150;
            const startX = 30;
            const startY = canvas.height - 30;
            
            chartData.forEach((value, index) => {
                const barHeight = (value / 100) * maxHeight;
                const x = startX + index * (barWidth + 10);
                const y = startY - barHeight;
                
                // 绘制柱状图
                ctx.fillStyle = `hsl(${index * 60}, 70%, 60%)`;
                ctx.fillRect(x, y, barWidth, barHeight);
                
                // 绘制数值
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(value, x + barWidth/2, y - 5);
            });
            
            // 绘制坐标轴
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(20, startY);
            ctx.lineTo(canvas.width - 20, startY);
            ctx.moveTo(20, startY);
            ctx.lineTo(20, 20);
            ctx.stroke();
        }
        
        function updateChart() {
            chartData = chartData.map(() => Math.floor(Math.random() * 100) + 10);
            drawChart();
        }
        
        // 清除画布
        function clearCanvas(canvasId) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
        
        // 初始化
        window.addEventListener('load', () => {
            setupDrawCanvas();
            drawShapes();
            drawChart();
        });
    </script>
</body>
</html>
```

---

## 🌐 常用Web API

### 地理位置API (Geolocation)

获取用户的地理位置信息。

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>地理位置API</title>
</head>
<body>
    <h2>📍 地理位置获取</h2>
    <button onclick="getLocation()">获取我的位置</button>
    <div id="locationInfo"></div>
    
    <script>
        function getLocation() {
            const info = document.getElementById('locationInfo');
            
            if (!navigator.geolocation) {
                info.innerHTML = '您的浏览器不支持地理位置API';
                return;
            }
            
            info.innerHTML = '正在获取位置信息...';
            
            navigator.geolocation.getCurrentPosition(
                function(position) {
                    const lat = position.coords.latitude;
                    const lon = position.coords.longitude;
                    const accuracy = position.coords.accuracy;
                    
                    info.innerHTML = `
                        <h3>位置信息</h3>
                        <p><strong>纬度:</strong> ${lat.toFixed(6)}</p>
                        <p><strong>经度:</strong> ${lon.toFixed(6)}</p>
                        <p><strong>精确度:</strong> ${accuracy} 米</p>
                        <p><a href="https://www.google.com/maps?q=${lat},${lon}" target="_blank">在地图中查看</a></p>
                    `;
                },
                function(error) {
                    switch(error.code) {
                        case error.PERMISSION_DENIED:
                            info.innerHTML = '用户拒绝了地理位置请求';
                            break;
                        case error.POSITION_UNAVAILABLE:
                            info.innerHTML = '位置信息不可用';
                            break;
                        case error.TIMEOUT:
                            info.innerHTML = '获取位置信息超时';
                            break;
                        default:
                            info.innerHTML = '获取位置信息时发生未知错误';
                            break;
                    }
                },
                {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 600000
                }
            );
        }
    </script>
</body>
</html>
```

### 本地存储API (Local Storage)

在浏览器中存储数据。

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>本地存储API</title>
    <style>
        .storage-demo {
            max-width: 600px;
            margin: 20px auto;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
        }
        
        .input-group {
            margin: 10px 0;
        }
        
        .input-group label {
            display: inline-block;
            width: 100px;
        }
        
        .input-group input {
            width: 200px;
            padding: 5px;
        }
        
        .stored-data {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div class="storage-demo">
        <h2>💾 本地存储演示</h2>
        
        <div class="input-group">
            <label for="keyInput">键名:</label>
            <input type="text" id="keyInput" placeholder="输入键名">
        </div>
        
        <div class="input-group">
            <label for="valueInput">值:</label>
            <input type="text" id="valueInput" placeholder="输入值">
        </div>
        
        <div class="input-group">
            <button onclick="saveData()">保存数据</button>
            <button onclick="loadData()">读取数据</button>
            <button onclick="deleteData()">删除数据</button>
            <button onclick="clearAll()">清空所有</button>
        </div>
        
        <div class="input-group">
            <label>读取结果:</label>
            <span id="readResult">-</span>
        </div>
        
        <div class="stored-data">
            <h3>已存储的数据</h3>
            <div id="storedList">暂无数据</div>
        </div>
    </div>
    
    <script>
        function saveData() {
            const key = document.getElementById('keyInput').value;
            const value = document.getElementById('valueInput').value;
            
            if (!key || !value) {
                alert('请输入键名和值');
                return;
            }
            
            localStorage.setItem(key, value);
            document.getElementById('keyInput').value = '';
            document.getElementById('valueInput').value = '';
            
            showStoredData();
            alert('数据保存成功');
        }
        
        function loadData() {
            const key = document.getElementById('keyInput').value;
            
            if (!key) {
                alert('请输入要读取的键名');
                return;
            }
            
            const value = localStorage.getItem(key);
            document.getElementById('readResult').textContent = value || '未找到该键';
        }
        
        function deleteData() {
            const key = document.getElementById('keyInput').value;
            
            if (!key) {
                alert('请输入要删除的键名');
                return;
            }
            
            localStorage.removeItem(key);
            showStoredData();
            alert('数据删除成功');
        }
        
        function clearAll() {
            if (confirm('确定要清空所有数据吗？')) {
                localStorage.clear();
                showStoredData();
                document.getElementById('readResult').textContent = '-';
            }
        }
        
        function showStoredData() {
            const list = document.getElementById('storedList');
            const keys = Object.keys(localStorage);
            
            if (keys.length === 0) {
                list.innerHTML = '暂无数据';
                return;
            }
            
            let html = '<ul>';
            keys.forEach(key => {
                const value = localStorage.getItem(key);
                html += `<li><strong>${key}:</strong> ${value}</li>`;
            });
            html += '</ul>';
            
            list.innerHTML = html;
        }
        
        // 页面加载时显示已存储的数据
        window.addEventListener('load', showStoredData);
    </script>
</body>
</html>
```

### 文件API (File API)

处理文件上传和读取。

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>文件API</title>
    <style>
        .file-demo {
            max-width: 600px;
            margin: 20px auto;
            padding: 20px;
        }
        
        .drop-zone {
            border: 2px dashed #ccc;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            margin: 20px 0;
            transition: all 0.3s;
        }
        
        .drop-zone.drag-over {
            border-color: #2196F3;
            background-color: #f0f8ff;
        }
        
        .file-info {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }
        
        .image-preview {
            max-width: 300px;
            max-height: 200px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div class="file-demo">
        <h2>📁 文件API演示</h2>
        
        <div class="drop-zone" id="dropZone">
            <p>拖放文件到这里或点击选择文件</p>
            <input type="file" id="fileInput" style="display: none;" multiple>
            <button onclick="document.getElementById('fileInput').click()">选择文件</button>
        </div>
        
        <div id="fileList"></div>
    </div>
    
    <script>
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const fileList = document.getElementById('fileList');
        
        // 文件拖放事件
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('drag-over');
        });
        
        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('drag-over');
        });
        
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('drag-over');
            
            const files = e.dataTransfer.files;
            handleFiles(files);
        });
        
        // 文件选择事件
        fileInput.addEventListener('change', (e) => {
            handleFiles(e.target.files);
        });
        
        function handleFiles(files) {
            fileList.innerHTML = '';
            
            Array.from(files).forEach((file, index) => {
                const fileInfo = document.createElement('div');
                fileInfo.className = 'file-info';
                
                const reader = new FileReader();
                
                if (file.type.startsWith('image/')) {
                    reader.onload = (e) => {
                        fileInfo.innerHTML = `
                            <h4>📷 ${file.name}</h4>
                            <p><strong>大小:</strong> ${formatFileSize(file.size)}</p>
                            <p><strong>类型:</strong> ${file.type}</p>
                            <p><strong>修改时间:</strong> ${new Date(file.lastModified).toLocaleString()}</p>
                            <img src="${e.target.result}" class="image-preview" alt="预览">
                        `;
                    };
                    reader.readAsDataURL(file);
                } else if (file.type.startsWith('text/')) {
                    reader.onload = (e) => {
                        fileInfo.innerHTML = `
                            <h4>📄 ${file.name}</h4>
                            <p><strong>大小:</strong> ${formatFileSize(file.size)}</p>
                            <p><strong>类型:</strong> ${file.type}</p>
                            <p><strong>修改时间:</strong> ${new Date(file.lastModified).toLocaleString()}</p>
                            <details>
                                <summary>查看内容</summary>
                                <pre style="max-height: 200px; overflow-y: auto; background: white; padding: 10px; border: 1px solid #ddd;">${e.target.result}</pre>
                            </details>
                        `;
                    };
                    reader.readAsText(file);
                } else {
                    fileInfo.innerHTML = `
                        <h4>📎 ${file.name}</h4>
                        <p><strong>大小:</strong> ${formatFileSize(file.size)}</p>
                        <p><strong>类型:</strong> ${file.type}</p>
                        <p><strong>修改时间:</strong> ${new Date(file.lastModified).toLocaleString()}</p>
                        <p>此文件类型不支持预览</p>
                    `;
                }
                
                fileList.appendChild(fileInfo);
            });
        }
        
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
    </script>
</body>
</html>
```

### Web Workers

在后台线程中运行JavaScript代码。

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Web Workers演示</title>
    <style>
        .worker-demo {
            max-width: 600px;
            margin: 20px auto;
            padding: 20px;
        }
        
        .result-area {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
            min-height: 100px;
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress {
            height: 100%;
            background-color: #4CAF50;
            width: 0%;
            transition: width 0.3s;
        }
    </style>
</head>
<body>
    <div class="worker-demo">
        <h2>⚡ Web Workers演示</h2>
        
        <h3>计算密集型任务</h3>
        <p>使用Web Worker在后台计算，不阻塞主线程UI</p>
        
        <button onclick="startCalculation()">开始计算（使用Worker）</button>
        <button onclick="startCalculationSync()">开始计算（主线程）</button>
        <button onclick="stopCalculation()">停止计算</button>
        
        <div class="progress-bar">
            <div class="progress" id="progressBar"></div>
        </div>
        
        <div class="result-area" id="resultArea">
            点击按钮开始计算...
        </div>
        
        <h3>实时时钟</h3>
        <p>验证主线程是否被阻塞</p>
        <div id="clock" style="font-size: 24px; font-weight: bold; color: #2196F3;"></div>
    </div>
    
    <script>
        let worker;
        
        function startCalculation() {
            if (worker) {
                worker.terminate();
            }
            
            // 创建Worker脚本
            const workerScript = `
                let isRunning = false;
                
                self.addEventListener('message', function(e) {
                    if (e.data.command === 'start') {
                        isRunning = true;
                        calculatePrimes(e.data.max);
                    } else if (e.data.command === 'stop') {
                        isRunning = false;
                    }
                });
                
                function calculatePrimes(max) {
                    const primes = [];
                    
                    for (let num = 2; num <= max && isRunning; num++) {
                        let isPrime = true;
                        
                        for (let i = 2; i <= Math.sqrt(num); i++) {
                            if (num % i === 0) {
                                isPrime = false;
                                break;
                            }
                        }
                        
                        if (isPrime) {
                            primes.push(num);
                        }
                        
                        // 报告进度
                        if (num % 1000 === 0) {
                            self.postMessage({
                                type: 'progress',
                                current: num,
                                max: max,
                                found: primes.length
                            });
                        }
                    }
                    
                    if (isRunning) {
                        self.postMessage({
                            type: 'complete',
                            primes: primes,
                            total: primes.length
                        });
                    }
                }
            `;
            
            // 创建Worker
            const blob = new Blob([workerScript], { type: 'application/javascript' });
            worker = new Worker(URL.createObjectURL(blob));
            
            // 监听Worker消息
            worker.addEventListener('message', function(e) {
                const data = e.data;
                
                if (data.type === 'progress') {
                    const progress = (data.current / data.max) * 100;
                    document.getElementById('progressBar').style.width = progress + '%';
                    document.getElementById('resultArea').innerHTML = `
                        <h4>计算进行中... (Web Worker)</h4>
                        <p>已处理: ${data.current.toLocaleString()} / ${data.max.toLocaleString()}</p>
                        <p>已找到质数: ${data.found.toLocaleString()} 个</p>
                        <p style="color: green;">✅ 主线程未被阻塞，时钟正常运行</p>
                    `;
                } else if (data.type === 'complete') {
                    document.getElementById('progressBar').style.width = '100%';
                    document.getElementById('resultArea').innerHTML = `
                        <h4>计算完成! (Web Worker)</h4>
                        <p>总共找到 ${data.total.toLocaleString()} 个质数</p>
                        <p>前10个质数: ${data.primes.slice(0, 10).join(', ')}</p>
                        <p style="color: green;">✅ 计算在后台完成，主线程畅通无阻</p>
                    `;
                }
            });
            
            // 开始计算
            worker.postMessage({ command: 'start', max: 100000 });
        }
        
        function startCalculationSync() {
            document.getElementById('resultArea').innerHTML = '<h4>计算进行中... (主线程)</h4><p style="color: red;">⚠️ 主线程被阻塞，时钟会停止</p>';
            document.getElementById('progressBar').style.width = '0%';
            
            // 使用setTimeout让UI有机会更新
            setTimeout(() => {
                const primes = [];
                const max = 100000;
                
                for (let num = 2; num <= max; num++) {
                    let isPrime = true;
                    
                    for (let i = 2; i <= Math.sqrt(num); i++) {
                        if (num % i === 0) {
                            isPrime = false;
                            break;
                        }
                    }
                    
                    if (isPrime) {
                        primes.push(num);
                    }
                }
                
                document.getElementById('progressBar').style.width = '100%';
                document.getElementById('resultArea').innerHTML = `
                    <h4>计算完成! (主线程)</h4>
                    <p>总共找到 ${primes.length.toLocaleString()} 个质数</p>
                    <p>前10个质数: ${primes.slice(0, 10).join(', ')}</p>
                    <p style="color: red;">❌ 计算阻塞了主线程，时钟暂停了一段时间</p>
                `;
            }, 100);
        }
        
        function stopCalculation() {
            if (worker) {
                worker.postMessage({ command: 'stop' });
                worker.terminate();
                worker = null;
                
                document.getElementById('resultArea').innerHTML = '<p>计算已停止</p>';
                document.getElementById('progressBar').style.width = '0%';
            }
        }
        
        // 实时时钟
        function updateClock() {
            const now = new Date();
            const timeString = now.toLocaleTimeString();
            document.getElementById('clock').textContent = timeString;
        }
        
        // 每秒更新时钟
        setInterval(updateClock, 1000);
        updateClock();
    </script>
</body>
</html>
```

---

## 🎯 实践练习

### 练习1：多媒体播放器
创建一个包含以下功能的多媒体播放器：
- 音频和视频播放
- 自定义控制按钮
- 播放列表
- 音量控制

### 练习2：Canvas绘图应用
开发一个Canvas绘图应用，包含：
- 多种绘图工具（画笔、直线、矩形、圆形）
- 颜色选择器
- 撤销/重做功能
- 保存图片功能

### 练习3：Web API综合应用
创建一个个人信息管理应用：
- 地理位置记录
- 照片上传和预览
- 数据本地存储
- 后台数据同步（使用Web Workers）

---

## 📋 学习检查点

### 知识点检查
完成学习后，你应该能够回答：

1. **多媒体相关**：
   - [ ] HTML5音频和视频标签的基本使用方法
   - [ ] 如何创建自定义媒体控制器
   - [ ] 音频和视频的事件处理
   - [ ] 媒体文件格式和浏览器兼容性

2. **Canvas相关**：
   - [ ] Canvas的基本绘图API
   - [ ] 如何绘制基本图形和路径
   - [ ] Canvas动画的实现原理
   - [ ] Canvas事件处理和交互

3. **Web API相关**：
   - [ ] 地理位置API的使用和权限处理
   - [ ] 本地存储的不同方式和特点
   - [ ] 文件API的读取和处理方法
   - [ ] Web Workers的使用场景和实现

### 实践技能检查
- [ ] 能够创建包含音频/视频的网页
- [ ] 能够使用Canvas绘制图形和动画
- [ ] 能够实现文件上传和预览功能
- [ ] 能够使用本地存储保存用户数据
- [ ] 能够获取用户地理位置信息
- [ ] 能够使用Web Workers处理耗时任务

---

## ❓ 常见问题

### Q1：为什么我的音频/视频无法自动播放？
**A**：现代浏览器为了用户体验，限制了媒体的自动播放。需要用户交互后才能播放，或者将媒体设置为静音。

### Q2：Canvas绘制的图像在高分辨率屏幕上模糊怎么办？
**A**：需要考虑设备像素比（devicePixelRatio），调整Canvas的实际尺寸和CSS尺寸。

### Q3：地理位置API返回权限被拒绝？
**A**：用户需要在浏览器中允许位置访问权限，且HTTPS环境下更容易获得权限。

### Q4：本地存储有大小限制吗？
**A**：localStorage通常有5-10MB的限制，超出限制会抛出异常。

### Q5：Web Workers可以访问DOM吗？
**A**：不可以，Web Workers运行在独立线程中，不能直接访问DOM，只能通过消息传递与主线程通信。

---

## 📚 参考资源

### 官方文档
- [MDN - HTML5 Audio](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/audio)
- [MDN - HTML5 Video](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video)
- [MDN - Canvas API](https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API)
- [MDN - Geolocation API](https://developer.mozilla.org/zh-CN/docs/Web/API/Geolocation_API)
- [MDN - Web Storage API](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API)
- [MDN - File API](https://developer.mozilla.org/zh-CN/docs/Web/API/File_API)
- [MDN - Web Workers](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API)

### 在线工具
- [Can I Use](https://caniuse.com/) - 检查API兼容性
- [HTML5 Test](http://html5test.com/) - 浏览器HTML5支持测试
- [Web API Demos](https://developer.mozilla.org/zh-CN/docs/Web/Demos) - MDN演示集合

### 学习资源
- [HTML5 Rocks](https://www.html5rocks.com/) - HTML5技术文章
- [Canvas Tutorial](https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial) - Canvas完整教程

---

**明日预习**：第5天将学习"网页性能优化基础"，了解网页性能指标、优化技术和监控工具，为创建高性能的Web应用做准备。

**学习建议**：
1. 多动手实践，尝试不同的API组合
2. 注意浏览器兼容性和用户体验
3. 理解异步编程的概念，为JavaScript学习做准备
4. 关注安全性，特别是文件处理和地理位置信息
5. 尝试创建完整的应用，整合多个API功能